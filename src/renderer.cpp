#include "lambda.h"

void errorFunction(void* userPtr, enum RTCError error, const char* str)
{
  printf("error %d: %s\n", error, str);
}

RTCDevice initializeDevice()
{
  RTCDevice device = rtcNewDevice(NULL);

  if (!device)
    printf("error %d: cannot create device\n", rtcGetDeviceError(NULL));

  rtcSetDeviceErrorFunction(device, errorFunction, NULL);
  return device;
}
RTCScene initializeScene(RTCDevice device)
{
  RTCScene scene = rtcNewScene(device);

  /*
   * Create a triangle mesh geometry, and initialize a single triangle.
   * You can look up geometry types in the API documentation to
   * find out which type expects which buffers.
   *
   * We create buffers directly on the device, but you can also use
   * shared buffers. For shared buffers, special care must be taken
   * to ensure proper alignment and padding. This is described in
   * more detail in the API documentation.
   */
  RTCGeometry geom = rtcNewGeometry(device, RTC_GEOMETRY_TYPE_TRIANGLE);
  float* vertices = (float*) rtcSetNewGeometryBuffer(geom,
                                                     RTC_BUFFER_TYPE_VERTEX,
                                                     0,
                                                     RTC_FORMAT_FLOAT3,
                                                     3*sizeof(float),
                                                     3);

  unsigned* indices = (unsigned*) rtcSetNewGeometryBuffer(geom,
                                                          RTC_BUFFER_TYPE_INDEX,
                                                          0,
                                                          RTC_FORMAT_UINT3,
                                                          3*sizeof(unsigned),
                                                          1);

  if (vertices && indices)
  {
    vertices[0] = 0.f; vertices[1] = 0.f; vertices[2] = 0.f;
    vertices[3] = 1.f; vertices[4] = 0.f; vertices[5] = 0.f;
    vertices[6] = 0.f; vertices[7] = 1.f; vertices[8] = 0.f;

    indices[0] = 0; indices[1] = 1; indices[2] = 2;
  }

  /*
   * You must commit geometry objects when you are done setting them up,
   * or you will not get any intersections.
   */
  rtcCommitGeometry(geom);

  /*
   * In rtcAttachGeometry(...), the scene takes ownership of the geom
   * by increasing its reference count. This means that we don't have
   * to hold on to the geom handle, and may release it. The geom object
   * will be released automatically when the scene is destroyed.
   *
   * rtcAttachGeometry() returns a geometry ID. We could use this to
   * identify intersected objects later on.
   */
  rtcAttachGeometry(scene, geom);
  rtcReleaseGeometry(geom);

  /*
   * Like geometry objects, scenes must be committed. This lets
   * Embree know that it may start building an acceleration structure.
   */
  rtcCommitScene(scene);

  return scene;
}

/*
 * Cast a single ray with origin (ox, oy, oz) and direction
 * (dx, dy, dz).
 */

Lt::Ray ray_create(Lt::Vec3f origin, Lt::Vec3f direction){
    Lt::Ray ray = {
        origin,
        direction
    };

    return ray;
}

bool ray_cast(RTCScene *scene, Lt::Ray ray){


    struct RTCIntersectContext context;
    rtcInitIntersectContext(&context);

    struct RTCRayHit rayhit;
    rayhit.ray.org_x = ray.origin.x;
    rayhit.ray.org_y = ray.origin.y;
    rayhit.ray.org_z = ray.origin.z;
    rayhit.ray.dir_x = ray.direction.x;
    rayhit.ray.dir_y = ray.direction.y;
    rayhit.ray.dir_z = ray.direction.z;
    rayhit.ray.tnear = 0;
    rayhit.ray.tfar = FLT_MAX;
    rayhit.ray.mask = 0;
    rayhit.ray.flags = 0;
    rayhit.hit.geomID = RTC_INVALID_GEOMETRY_ID;
    rayhit.hit.instID[0] = RTC_INVALID_GEOMETRY_ID;

}


// void castRay(RTCScene scene,
//              float ox, float oy, float oz,
//              float dx, float dy, float dz)
// {
//   /*
//    * The intersect context can be used to set intersection
//    * filters or flags, and it also contains the instance ID stack
//    * used in multi-level instancing.
//    */
//   struct RTCIntersectContext context;
//   rtcInitIntersectContext(&context);

//   /*
//    * The ray hit structure holds both the ray and the hit.
//    * The user must initialize it properly -- see API documentation
//    * for rtcIntersect1() for details.
//    */
//   struct RTCRayHit rayhit;
//   rayhit.ray.org_x = ox;
//   rayhit.ray.org_y = oy;
//   rayhit.ray.org_z = oz;
//   rayhit.ray.dir_x = dx;
//   rayhit.ray.dir_y = dy;
//   rayhit.ray.dir_z = dz;
//   rayhit.ray.tnear = 0;
//   rayhit.ray.tfar = std::numeric_limits<float>::infinity();
//   rayhit.ray.mask = 0;
//   rayhit.ray.flags = 0;
//   rayhit.hit.geomID = RTC_INVALID_GEOMETRY_ID;
//   rayhit.hit.instID[0] = RTC_INVALID_GEOMETRY_ID;

//   /*
//    * There are multiple variants of rtcIntersect. This one
//    * intersects a single ray with the scene.
//    */
//   rtcIntersect1(scene, &context, &rayhit);

//   printf("%f, %f, %f: ", ox, oy, oz);
//   if (rayhit.hit.geomID != RTC_INVALID_GEOMETRY_ID)
//   {
//     /* Note how geomID and primID identify the geometry we just hit.
//      * We could use them here to interpolate geometry information,
//      * compute shading, etc.
//      * Since there is only a single triangle in this scene, we will
//      * get geomID=0 / primID=0 for all hits.
//      * There is also instID, used for instancing. See
//      * the instancing tutorials for more information */
//     printf("Found intersection on geometry %d, primitive %d at tfar=%f\n",
//            rayhit.hit.geomID,
//            rayhit.hit.primID,
//            rayhit.ray.tfar);
//   }
//   else
//     printf("Did not find any intersection.\n");
// }
